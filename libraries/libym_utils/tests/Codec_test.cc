
/// @file Codec_test.cc
/// @brief FileCoder/FileDecoder のテストプログラム
/// @author Yusuke Matsunaga (松永 裕介)
///
/// Copyright (C) 2013 Yusuke Matsunaga
/// All rights reserved.


#include "ym_utils/FileCoder.h"
#include "ym_utils/FileDecoder.h"
#include <fcntl.h>


BEGIN_NAMESPACE_YM

BEGIN_NONAMESPACE

// 圧縮に用いるファイルの内容
ymuint8 data[] = "//////////////////////////////////////////////////////////////////////\n"
"// ymtools のビルドについて\n"
"//						松永　裕介\n"
"//                                             ????.??.?? Ver.1\n"
"//                                             2013.11.20 Ver.2\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"これには少々複雑な手順を必要とします．大まかには次のような4つのステッ\n"
"プを踏みます．\n"
"\n"
" 0. ビルドに必要なツールのインストール\n"
" 1. configure スクリプトの生成\n"
" 2. autogen スクリプトの生成\n"
" 3. configure の実行(Makefileの生成)\n"
" 4. make\n"
"\n"
"このうち 0 は普通に GNU のソフトウェア開発環境がインストールされていれ\n"
"ばスキップできます．1 と 2 はソースをチェックアウトした時に1回だけ行う\n"
"必要があります．3 はソースファイルを変更したら毎回実行する必要があります．\n"
"また，コンパイルオプションを変えたり，異なる環境やコンパイラでコンパイ\n"
"ルし直すときは 2 を実行する必要があります．さらに，後述するように一つ\n"
"のソースから複数のコンパイルオプションやプラットフォームに応じたバイナ\n"
"リを生成することも可能です．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// 0 ビルドに必要なツールのインストール\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"ymtools のビルドに必要なツールは以下のとおりです．\n"
"\n"
"- gcc/g++\n"
"- lex (flex)\n"
"- yacc (bison)\n"
"- autoconf\n"
"- automake\n"
"- libtool\n"
"- tcl\n"
"- tclreadline\n"
"- popt\n"
"- gmp\n"
"- python\n"
"- Qt\n"
"- CppUTest\n"
"\n"
"以下に個々のツールについて補足します．\n"
"\n"
"○ gcc/g++\n"
" 現在，FreeBSD-8 の gcc-4.2.1 および FreeBSD-9 の gcc-4.3 でテストしています．\n"
" Linux (Cent-OS?) 上の gcc-3.4.6 でテスト済みです．\n"
"\n"
"○ lex (flex)\n"
" 現在，flex-2.5.4 でテストしています．\n"
"\n"
"○ yacc (bison)\n"
" 現在，bison-2.4.3, bison-2.5 でテストしています．\n"
"bison を yacc 互換で動かすためには bison -y とします．\n"
"bison-1.X.X では %define api.pure ディレクティブを理解してくれないの\n"
"で動きません．\n"
"\n"
"○ autoconf\n"
" 現在，autoconf-2.68, autoconf-2.69 でテストしています．\n"
" autoconf はバージョンが変わる\n"
"とマクロが結構変わるのでできる限り最新の autoconf を使う必要があります．\n"
"\n"
"○ automake\n"
" 現在，automake-1.11.1, automake-1.12 でテストしています．autoconf と同様です．\n"
"\n"
"○ libtool\n"
" 現在，libtool-2.4.2 でテストしています．autoconf と同様です．\n"
"\n"
"○ tcl\n"
" 現在，tcl-8.5 でテストしています．8.4 などでも動くと思います．\n"
"\n"
"○ tclreadline\n"
" 現在，tclreadline-2.1.0 でテストしています．\n"
"\n"
"○ popt\n"
" 現在，popt-1.16 でテストしています．\n"
"\n"
"○ gmp\n"
" 現在，gmp-5.0.1 でテストしています．もしも gmp をソースからビルドして\n"
" インストールする場合には，configure 時に --enable-cxx をつけるよう\n"
" にしてください(*1)．\n"
"\n"
"○ python\n"
" 現在，python-2.7.3 でテストしています．\n"
"\n"
"○ Qt\n"
" 現在，Qt-4.7.4 でテストしています．\n"
"\n"
"○ CppUTest\n"
" 現在，cpputest-3.5 でテストしています．\n"
"\n"
"\n"
"0.1 上記ツールがインストールされていない場合の対処\n"
"\n"
"一番簡単なのは，計算機の管理者にいって，上記のツールの最新バージョンを\n"
"インストールしてもらうことですが，それが難しい場合には自分でソースをもっ\n"
"てきて，configure; make; make install する必要があります．\n"
"その場合，ymtools 用のディレクトリを用意してそこにこれら一連のツールを\n"
"インストールすることをおすすめします．例えば，ymtools 用に，\n"
"\n"
"/project/ymtools\n"
"\n"
"というディレクトリを用意したとします(別にこれは自分のホームディレクト\n"
"リの下でも構いません)．\n"
"例えば，autoconf をインストールする際に，autoconf のソースディレクトリ\n"
"に移って，\n"
"\n"
"./configure --prefix=/project/ymtools\n"
"make\n"
"make install\n"
"\n"
"とすれば，/project/ymtools/bin/autoconf などがインストールされます．\n"
"同様に，gmp も\n"
"\n"
"./configure --prefix=/project/ymtools --enable-cxx(*1)\n"
"make\n"
"make install\n"
"\n"
"とすれば，/project/ymtools/lib/libgmpxx.so などのファイルがインストー\n"
"ルされます．\n"
"\n"
"これら，自分でインストールしたツールを ymtools のビルドに使う場合の指\n"
"定の仕方ですが，大きく分けて3つの場合があります．\n"
"\n"
"- ymtools の boot.sh を実行するのに必要なもの\n"
" autoconf, automake, libtool がこれに当たります．補足 A-3 にしたがって\n"
"適切な環境変数をセットしてください．\n"
"\n"
"- ymtools の configure 時に必要なもの\n"
" ymtools のビルドディレクトリ(2.1参照)で autogen を実行する時に必要と\n"
"なるもので，tcl, tclreadline, gmp, popt, python, Qt, CppUTest\n"
"がこれに当たります．\n"
"これらは ./configure に対するオプションの形でインストールされている場\n"
"所を指定する必要があります．実際には autogen.common もしくは\n"
" autogen.local というファイルを作ってそこに書いておけば，毎回，オプショ\n"
" ンを手で打ち込む必要はありません．具体的な方法は A-2 を参照してください．\n"
"\n"
"- ymtools のコンパイル時に必要なもの\n"
" gcc, lex, yacc がこれに当たります．具体的には以下の環境変数を\n"
"configure 時(./autogen 実行中)にセットしておく必要があります．\n"
"\n"
"CC:   C コンパイラを指定します．\n"
"CXX:  C++ コンパイラを指定します．\n"
"LEX:  lex を指定します．\n"
"YACC: yacc を指定します．\n"
"\n"
"指定の仕方は補足 A-2 にしたがって行います．\n"
"\n"
"たとえば，autogen.common/autogen.local に以下のような行を加えておけば，\n"
"/project/ymtools\n"
"以下にインストールしたツールを使うようになります(ちなみに\n"
"autogen.common/autogen.local は bash スクリプトです)．\n"
"\n"
"export CC=/project/ymtools/bin/gcc-4.2.1\n"
"export CXX=/project/ymtools/bin/g++-4.2.1\n"
"export LEX=/project/ymtools/bin/flex-2.5.4\n"
"export YACC=/project/ymtools/bin/bison-2.4.3 -y\n"
"\n"
"実際にどのような名前でプログラムがインストールされているかは確かめてく\n"
"ださい．上のようになるとは限りません．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// 1 configure スクリプトの生成\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"ここでは autoconf, automake, libtool 等を用いて ymtools 直下の configure\n"
"スクリプトを生成します．これは実はだれかが一回行えば良いのでステップ1\n"
"が終わった状態で git レポジトリにインポートしても良いのですが，\n"
"自動で生成されるファイルを git に登録するのは無駄なので普通は登録しません．\n"
"で，ステップ1では autoconf, automake, libtool などを必要とするのですが，\n"
"計算機によってはインストールされていない，または古いバージョンがインス\n"
"トールされている等の問題が起る場合があります．この時は 0 章を参照に自\n"
"分でこれらのツールをインストールするか，既にツールがインストールされて\n"
"いる別のでマシンでこのステップを実行してください(ホームディレクトリな\n"
"どがネットワークで共有されている場合)．\n"
"\n"
"で，すべての環境において ymtools 直下で\n"
"\n"
"./boot.sh\n"
"\n"
"と打ち込めばステップ1は終了です．\n"
"ここでエラーが起きるときには autoconf, automake などのバージョンを確認\n"
"してください．たとえば autoconf が autoconf2.13 で別に autoconf257 な\n"
"んていう名前で autoconf2.57 がインストールされていたら autoconf257 が\n"
"使われるように環境変数を設定してください(後述)\n"
"\n"
"\n"
"ステップ1で生成されたファイルを消すには\n"
"\n"
"./clean.sh\n"
"\n"
"と打ち込んでください．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// 2.1 configure の実行 (その1)\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"ここではステップ1で生成された configure スクリプトを実行して Makefile\n"
"を生成します．ただし，「ここ」ではそれを実行することはあまりおすすめで\n"
"きません．\n"
"ソースファイルのある場所でコンパイルすることも可能ですが，できればコン\n"
"パイルするディレクトリを他に用意することをお勧めします．というのはソー\n"
"スディレクトリはその後 git に登録することがあるので「きれいな」状態に\n"
"しておくことが望ましいからです．また，同一のソースから FreeBSD,\n"
"RedHat, Solaris などの異なるプラットフォーム用のバイナリを生成するとき\n"
"にも複数のビルド用ディレクトリを用意したほうが便利です．\n"
"\n"
"それでもここでやりたいのであれば，\n"
"\n"
"cd $SRCDIR\n"
"./configure <options>\n"
"make\n"
"make install\n"
"\n"
"で，一応はできるはずです．\n"
"ただし，他のツールの場所などを <options> の中で指定する必要があります．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// 2.2 configure の実行 (その2)\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"ここではステップ1で生成された configure スクリプトを実行して Makefile\n"
"を生成します．ただし，「ここ」ではそれを実行しないでください．\n"
"ソースファイルのある場所でコンパイルすることも可能ですが，できればコン\n"
"パイルするディレクトリを他に用意することをお勧めします．というのはソー\n"
"スディレクトリはその後 git に登録することがあるので「きれいな」状態に\n"
"しておくことが望ましいからです．また，同一のソースから FreeBSD,\n"
"RedHat, Solaris などの異なるプラットフォーム用のバイナリを生成するとき\n"
"にも複数のビルド用ディレクトリを用意したほうが便利です．\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// 2.2.1 autogen スクリプトの生成\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"で，このようにビルド用ディレクトリに Makefile を作るには 1 で生成し\n"
"た configure スクリプトを走らせればよいのですが，これもいろいろと細々\n"
"した設定オプションがあり，何度も手で修正しながら configure を走らせる\n"
"のは手間がかかるし間違いのものなので，この作業を行う mkautogen というス\n"
"クリプトが用意されています．\n"
"これは，opt/debug/prof の3つのモード用のビルドディレクトリを一編に作っ\n"
"てくれるものです．使い方は\n"
"\n"
"cd $SRCDIR\n"
"./mkautogen.sh $PREFIX $ROOTNAME\n"
"\n"
"です．結果として，\n"
"\n"
"$PREFIX/build/$ROOTNAME/opt\n"
"                       /debug\n"
"                       /prof\n"
"$PREFIX/test/$ROOTNAME/opt\n"
"                      /debug\n"
"                      /prof\n"
"\n"
"という6つのディレクトリを作成し，各ビルド用ディレクトリの下に autogen\n"
"スクリプトを作ります．\n"
"$PREFIX/build/$ROOTNAME 以下にコンパイル結果のオブジェクトファイルが格\n"
"納されます．　\n"
"$PREFIX/test/$ROOTNAME 以下には make install を実行した時にファイルが\n"
"インストールされるディレクトリが作られます．\n"
"本当に /usr/local 以下とかにインストールしたい場合には autogen 中の\n"
"'dstdir' を書き換えればよいのですが，直接 autogen を書き換えずに\n"
"autogen.common/autogen.local に distdir=XXXX という行を追加した方がよ\n"
"いでしょう．詳しくは 「A-2 autogen.common/autogen.local の使用例」 を\n"
"読んでください．\n"
"また，$PREFIX/build/$ROOTNAME/Makefile というファイルも生成します．\n"
"通常は，\n"
"\n"
"cd $PREFIX/build/$ROOTNAME\n"
"make configure\n"
"make\n"
"(make install) <- ほとんど不要です．\n"
"\n"
"で3つのモードのすべてのオブジェクトを生成します．\n"
"3つのバージョンを同時に作る理由は，時間の計測などを行うには最適化オプ\n"
"ションをつけた方がいいけど，デバッグするにはシンボルが残っていなければ\n"
"いけないとか，コードの最適化用にはプロファイル用のオブジェクトがいると\n"
"かいろいろとオプションが異なるオブジェクトが必要な場合があるので，最初\n"
"から作っておけば手間が省けるだろうというわけです．昔に比べればディスク\n"
"も安いし計算機も速くなったのでこれくらいの無駄は無視できるのではないか\n"
"と思います．もちろん，\n"
"\n"
"cd $PREFIX/build/$ROOTNAME/opt\n"
"./autogen\n"
"make\n"
"\n"
"で最適化モードのオブジェクトのみ作ることも可能です．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// 2.2.2 autogen の実行\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"これは簡単で $PREFIX/build/$ROOTNAME/{opt,debug,prof} において\n"
"\n"
"./autogen\n"
"\n"
"とするだけです．autogen スクリプトが自動的に configure を実行してくれ\n"
"ます．一回，configure を実行すると Makefile ができるので以後ソースファ\n"
"イルのMakefile.am 等を変更すると make で自動的に configure してくれる\n"
"ようになります．便利ですが，私もイマイチ完全に理解しているわけではない\n"
"ので，なんか変だなとおもったら一回，ファイルを消して configure しなお\n"
"してみてください．\n"
"\n"
"3つのディレクトリで個別に autogen を実行する代わりに\n"
"\n"
"cd $PREFIX/build/$ROOTNAME\n"
"make configure\n"
"\n"
"でも同様のことができます．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// 3 configure/autogen の再実行\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"ソースファイルやディレクトリを追加した場合には Makefile などを作り直す\n"
"必要があります．大まかには 1. configure の生成 と 2. configure の実行\n"
"を繰り返せば良いのですが，結構，時間がかかります．\n"
"たとえば libraries/libym_logic 以下のみが変更になった場合には\n"
"\n"
"cd $SRCDIR\n"
"./boot.sh libraries/libym_logic\n"
"\n"
"cd $PREFIX/build/$ROOTNAME\n"
"./update libraries/libym_logic\n"
"\n"
"で libraries/libym_logic 以下の Makefile だけ作り直せます．\n"
"update スクリプトは mkautogen を実行すると生成されているはずです．\n"
"\n"
"こまかなことですが，./boot.sh の時は実際に libraries/libym_logic\n"
"というディレクトリがあるので shell の completion が効きますが，\n"
"./update の時は，実際には {opt,debug,prof}/libraries/libym_logic\n"
"というディレクトリがあるので completion が効きません．指が completion\n"
"で退化している人は気をつけてください．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// 4 make の実行\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"こちらも簡単で\n"
"\n"
"cd $PREFIX/build/$ROOTNAME/{opt,debug,prof}\n"
"make\n"
"\n"
"でコンパイルできます．\n"
"もしくは\n"
"\n"
"cd $PREFIX/build/$ROOTNAME\n"
"make\n"
"\n"
"で3つのディレクトリに対して make を実行します．\n"
"\n"
"コンパイルが成功したら\n"
"\n"
"make install\n"
"\n"
"で $INSTALLDIR に種々のファイルをインストールします．\n"
"ちなみに $INSTALLDIR は存在していなければ新規に生成してくれるので\n"
"mkdir しておく必要はありません．\n"
"もちろん親のディレクトリに対する書き込み権限は必要です．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// A-1 boot.sh コマンドリファレンス\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"- configure の生成\n"
"  boot.sh\n"
"\n"
"- クリーンアップ\n"
"  clean.sh\n"
"\n"
"- autogen スクリプトの生成\n"
"\n"
"  mkautogen.sh <PREFIX> <ROOTNAME>\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// A-2 autogen.common/autogen.local 使用例\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"まず，autogen.common と autogen.local の違いですが，役割的には違いはあ\n"
"りません．autogen をみれば分かりますが，autogen.common が先に読み込ま\n"
"れて autogen.local が次に読み込まれます．\n"
"もちろん，これらのファイルが存在しない時は読み込まれません．\n"
"mkautogen.sh で opt, debug, prof の3つのディレクトリを作った場合，\n"
"その上のディレクトリにある autogen.common が commonconf ファイルになり\n"
"ます．\n"
"つまり，opt, debug, prof ごとに必要な設定は autogen.local に書いて，共\n"
"通な設定は autogen.common に書くのがよいでしょう．\n"
"autogen.common と autogen.local の位置関係は以下のようになります．\n"
"\n"
"$PREFIX/build/autogen.common\n"
"	     /opt/autogen.local\n"
"             /debug/autogen.local\n"
"	     /prof/autogen.local\n"
"\n"
"mkautogen.sh 実行時に環境変数 AUTOGEN_COMMON が設定されていればその内\n"
"容が commonconf の値となります．例えば，/proj/ymtools/agcommon\n"
"というファイルを作っておいて，\n"
"export AUTOGEN_COMMON=\"/proj/ymtools/agcommon\"\n"
"のあとで mkautogen.sh を実行すれば，この .../agcommon というファイル共\n"
"通の設定ファイルになります．\n"
"\n"
"よくある autogen.common/autogen.local の使い方としては tcl/tk のインス\n"
"トール先の指定や popt のインストール先の指定，マシン依存の最適化オプショ\n"
"ンの指定などがあります．\n"
"\n"
"これは configure のオプションとして指定します．たとえば\n"
"\n"
"--with-tcl=/foo/bar\n"
"\n"
"というオプションを付加したい場合には autogen.local に\n"
"\n"
"$optflags=\"$optflags --with-tcl=/foo/bar\"\n"
"\n"
"という行を追加してください．もとの $optflags の値を消してしまわないよ\n"
"うに注意してください．\n"
"\n"
"まず，tcl/tk ですが，たとえば /foo/bar 以下に tcl(tk) がインストール\n"
"されているとすると /foo/bar/lib/tclConfig.sh(tkConfig.sh) というファイ\n"
"ルがあるはずです．\n"
"これが普通のディレクトリ(/usr/local とか)なら configure スクリプトが自\n"
"動的に tcl を見つけてくれるのですが，\n"
"\n"
"/opt/export/lib/mytcl/tclConfig.sh\n"
"\n"
"とかいう不規則な場所に tcl がインストールされていると configure が tcl\n"
"を見つけることができません．そのような場合には configure に次のような\n"
"オプションを付ける必要があります．\n"
"\n"
"--with-tcl=/opt/export/lib/mytcl\n"
"\n"
"tclConfig.sh はその名の通り sh スクリプトで実行することで tcl のインス\n"
"トール先のディレクトリとかリンク時のオプションとかがわかるようになって\n"
"います．通常ヘッダファイルもここからわかるのですが，もしもヘッダファイ\n"
"ルが見つからない場合には\n"
"\n"
"--with-tcl-includes=<ヘッダファイルのあるディレクトリ>\n"
"\n"
"を指定します．tk も同様です．\n"
"\n"
"popt パッケージも似ていますが，こちらは popt.h がある場所が\n"
"\n"
"/foo/bar/include/popt.h\n"
"\n"
"だった場合には --with-popt-prefix=/foo/bar\n"
"\n"
"と指定します．ライブラリは /foo/bar/lib の下にあると仮定します．\n"
"もしも /foo/bar/lib 以外の場所(たとえば /xxx/zzz/ の下)にあるときには\n"
"\n"
"--with-popt-libdir=/xxx/zzz\n"
"\n"
"と指定します．\n"
"\n"
"また，以下の環境変数をセットしておくとコンパイラの設定ができます．\n"
"なければ適当なものが使われます．\n"
"\n"
"CC: Cコンパイラを指定します．\n"
"CXX: C++コンパイラを指定します．\n"
"CFLAGS: Cコンパイラに渡すコンパイルオプションを指定します．\n"
"CXXFLAGS: C++コンパイラに渡すコンパイルオプションを指定します．\n"
"\n"
"実は ymtools は C++ しか使ってません．\n"
"これらを autogen.local で指定するには\n"
"\n"
"export CXX=g++34\n"
"\n"
"の様にしてください．また，pentium4 用の最適化をしたければ\n"
"\n"
"CXXFLAGS=\"$CXXFLAGS -march=pentium4\"\n"
"\n"
"の様にコンパイルオプションを追加します．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// A-3 環境変数について\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"boot.sh は内部で使うコマンド(autoconf, automakeなど)を勝手に推測します\n"
"が，特定のバージョンや特定のパスにあるプログラムを使いたいときには環境\n"
"変数で指定することができます．以下にその環境変数とそのデフォルト値を示\n"
"します．\n"
"\n"
"環境変数名        意味				デフォルト値\n"
"\n"
"AUTOHEADER　　　　autoheader コマンドのパス名	autoheader(*1)\n"
"AUTOHEADER_FLAGS  autoheader のオプション	なし\n"
"AUTOCONF          autoconf コマンドのパス名	autoconf(*1)\n"
"AUTOCONF_FLAGS	  autoconf のオプション		なし\n"
"ACLOCAL           aclocal コマンドのパス名	aclocal(*1)\n"
"ACLOCAL_FLAGS     aclocal のオプション		なし\n"
"AUTOMAKE          automake コマンドのパス名	automake(*1)\n"
"AUTOMAKE_FLAGS    automake のオプション		なし\n"
"LIBTOOLIZE        libtoolize コマンドのパス名	libtoolize(*1)\n"
"LIBTOOLIZE_FLAGS  libtoolize のオプション	なし\n"
"M4                m4 コマンドのパス名		m4\n"
"FIND              find コマンドのパス名		find\n"
"RM                rm コマンドのパス名		rm\n"
"\n"
"*1: FreeBSD の場合バージョンごとに autoconf259 のようなコマンド名にな\n"
" るので自動的に最新版を使用する\n"
" <== 最近の FreeBSD は最新版が autoconf にリンクされるようになった．\n"
"\n"
"ほとんどの場合 XXXX_FLAGS は指定する必要はないと思いますが，autoconf\n"
"用のマクロが通常と異なる場所に置いてある場合には AUTOHEADER_FLAGS で\n"
"\"-I <そのディレクトリ>\" を指定する必要があります．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// B 上級編\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"実は ymtools はライブラリ群である ymlibs と magus をはじめとするいくつ\n"
"かのアプリケーションから成り立っています(magus 以外のアプリケーション\n"
"はオマケ程度)．これらは個別に configure/make することが可能です．\n"
"また，ymlibs のなかのライブラリの個別に make するかどうかをコントロー\n"
"ルすることが可能です．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// B-1 サブパッケージの configure/make\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"ymtools のトップディレクトリで boot.sh <subcommand> でいくつかの前処理\n"
"をおこないますが，これと同じことが以下のサブディレクトリ上の\n"
" boot.sh <subcommand> コマンドでおこなえます．\n"
"\n"
"./ (ymtools のトップディレクトリ)\n"
"libraries/libym_XXXX\n"
"programs/magus_tclsh 論理合成プログラム\n"
"        /atpg        テストパタン生成プログラム\n"
"        /matpg       テストパタン生成プログラム(松永が富士通研時代に作っ\n"
"	             たプログラムのレプリカ:知財的な問題はないはず)\n"
"        /lutmap      LUT型FPGA用テクノロジマッパ\n"
"        /led         この2つは無視してください．\n"
"        /seal\n"
"\n"
"用法は boot.sh と全く同じです．\n"
"実際，boot.sh は\n"
"\n"
"cd ./; boot.sh\n"
"cd ./libraries/libym_utils; boot.sh\n"
"cd ./libraries/libym_lexp; boot.sh\n"
"       .\n"
"       .\n"
"       .\n"
"cd ./programs/magus; boot.sh\n"
"cd ./programs/atpg; boot.sh\n"
"       .\n"
"       .\n"
"\n"
"と同義です．ただし，サブパッケージの configure ではいくつかの細かな設\n"
"定を行うことが可能です(後述)．\n"
"\n"
"magus その他のアプリケーションは libraries 以下のいくつかのライブラリ\n"
"に依存しているのでこれらのアプリケーションを作るためにはライブラリを作\n"
"成する必要があります．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// B-2 libraries の configure\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"現在，libraries には以下のライブラリが含まれます．\n"
"\n"
"libym_utils     汎用のユーティリティクラスライブラリ\n"
"libym_tclpp     Tcl インターフェイス\n"
"libym_verilog   Verilog フロントエンド\n"
"libym_logic     論理関数処理\n"
"libym_networks 	論理回路ネットワーク\n"
"libym_gds       GDS-II ファイルパーサー\n"
"libym_cec       組み合わせ回路の等価性検証\n"
"libym_cell      セルライブラリを扱うクラスライブラリ\n"
"libym_techmap   テクノロジマッパ\n"
"libym_mincov    最小被覆問題ソルバ\n"
"libym_seal      ソフトエラー耐性評価用\n"
"\n"
"ほとんどの場合，libym_utils は必須ですが，それ以外は不要な場合がありま\n"
"す．そこで，これらのライブラリは(libym_utilsも含めて) make するかどう\n"
"かを選択できるようになっています．\n"
"具体的には configure 時に\n"
"\n"
"--enable-libym_utils\n"
"\n"
"のようなオプションを加えることで libym_utils を生成する様に指示できま\n"
"す．もっとも libym_utils はデフォルトで生成する様になっています．\n"
"\n"
"各ライブラリやプログラムは自分が依存しているライブラリの情報を\n"
"configure.ac 中の YM_BUILD_LIBRARY マクロで判断します．\n"
"たとえば，\n"
"\n"
"# libym_logic\n"
"YM_BUILD_LIBRARY([libym_logic], [yes],\n"
"		 [ym_libym_utils_enable])\n"
"\n"
"この記述は libym_logic 以下のディレクトリをビルドするためには\n"
"ym_libym_utils_enable が yes である必要がある，という意味です．\n"
"二番目の引数の [yes] はデフォルトでこのライブラリを生成する設定になっ\n"
"ていることを指定しています．\n"
"ここのライブラリを生成するかはこのパラメータでも制御できますが，\n"
"autogen.local 中に\n"
"\n"
"optflags=\"$optflags --enable-libym_logic\"\n"
"\n"
"という行を加えるやり方のほうがよいでしょう．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// B-3 magus の configure\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"特記事項なし．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// B-4 tclreadline の configure\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"tclreadline は tcl/tk の対話型シェルにおいて履歴置換や行内編集，補間な\n"
"どを可能にする tcl/tk のパッケージです．tclreadline は tclsh や wish\n"
"に対して動的にリンクすることが可能なので，ymtools/magus と独立にコンパ\n"
"イルしたパッケージを起動時に読み込んでリンクすれば使うことができますが，\n"
"tclreadline がインストールされていないシステム上で使うことを考えて\n"
"ymtools ディレクトリの下に tclreadline のソースツリーが入っています．\n"
"これをコンパイルするには ymtools の configure 時に\n"
"\n"
"--enable-tclreadline\n"
"\n"
"オプションを付ければOKです．実際には tclreadline のコンパイルはデフォ\n"
"ルトで on になっているので，コンパイルしたくないときだけ\n"
"\n"
"--disable-tclreadline\n"
"\n"
"を付けてください．\n"
"\n"
"さらに，magus_tclsh に静的に tclreadline をリンクしておく\n"
"ことも可能です．これを行うには magus の configure 時に\n"
"\n"
"--with-tclreadline=XXX\n"
"--with-tclreadline-include=YYYY\n"
"\n"
"オプションを指定してください．実際には，ymtools のビルドツリー上に\n"
"tclreadline/libtclreadline.la があって，ソースツリー上に tclreadline.h\n"
"がある場合や ${prefix}/lib と ${prefix}/include の下に\n"
"libtclreadline.la と tclreadline.h がある場合等，自動的に tclreadline\n"
"が見付けられた場合には勝手に組み込みます．tclreadline を組み込みたくな\n"
"い場合には\n"
"\n"
"--without-tclreadline\n"
"\n"
"を指定します．\n"
"\n"
"\n"
"//////////////////////////////////////////////////////////////////////\n"
"// B-5 CppUTest\n"
"//////////////////////////////////////////////////////////////////////\n"
"\n"
"部分的に CppUTest を用いたテストコードを導入しています．\n"
"CppUTest がインストールされていれば，\n"
"\n"
"libym_logic/test/CppUTest/run_all_test\n"
"\n"
"のようなテストプログラムが生成されます．\n"
"これを実行してエラーがでなければ，(ここでチェックした範囲においては)\n"
"テストが通ったことになります．\n"
"将来的には根元の tests/CppUTest の下に run_all_test をまとめて作って\n"
"完全な regression test を行なえるようにする予定です．\n"
"\n"
"--END\n";

END_NONAMESPACE


int
codec_test1(tCodecType type)
{
  FileCoder* coder = FileCoder::new_coder(type);
  FileDecoder* decoder = FileDecoder::new_decoder(type);

  // 圧縮ファイル名を作るためのテンプレート
  char template_name[] = "/tmp/codec_test_temp.XXXXXXXX";

  // 圧縮ファイル名
  const char* tmpfile_name = mktemp(template_name);

  if ( !coder->open(tmpfile_name) ) {
    cerr << "Could not create file: " << tmpfile_name << endl;
    return -1;
  }

  ymuint rpos = 0;
  ymuint rsize = sizeof(data) / sizeof(char) - 1;

  const ymuint BUFF_SIZE = 4096;
  ymuint8 rbuff[BUFF_SIZE];
  for ( ; ; ) {
    ymuint n = rsize - rpos;
    if ( n == 0 ) {
      break;
    }
    if ( n > BUFF_SIZE ) {
      n = BUFF_SIZE;
    }
    for (ymuint i = 0; i < n; ++ i, ++ rpos) {
      rbuff[i] = data[rpos];
    }
    ssize_t n2 = coder->write(rbuff, n);
    if ( n2 != n ) {
      cerr << "Error in FileCoder::write() ==> " << n2 << endl;
      return -1;
    }
  }
  coder->close();

  if ( !decoder->open(tmpfile_name) ) {
    cerr << "Could not open file: " << tmpfile_name << endl;
    return -1;
  }

  rpos = 0;
  ymuint8 wbuff[BUFF_SIZE];
  for ( ; ; ) {
    ssize_t n = decoder->read(wbuff, BUFF_SIZE);
    if ( n < 0 ) {
      cerr << "Error in FileDecoder::read() ==> " << n << endl;
      return -1;
    }
    if ( n == 0 ) {
      break;
    }
    for (ymuint i = 0; i < n; ++ i, ++ rpos) {
      if ( data[rpos] != wbuff[i] ) {
	cerr << "Error data mismatch" << endl;
	return -1;
      }
    }
  }

  decoder->close();

  unlink(tmpfile_name);

  return 0;
}

int
codec_test()
{
  int ret = 0;

  ret = codec_test1(kCodecThrough);
  if ( ret < 0 ) {
    return ret;
  }

  ret = codec_test1(kCodecZ);
  if ( ret < 0 ) {
    return ret;
  }

#if defined(HAVE_ZLIB)
  ret = codec_test1(kCodecGzip);
  if ( ret < 0 ) {
    return ret;
  }
#endif

#if defined(HAVE_BZLIB)
  ret = codec_test1(kCodecBzip2);
  if ( ret < 0 ) {
    return ret;
  }
#endif

  return ret;
}

END_NAMESPACE_YM


int
main(int argc,
     const char** argv)
{
  using nsYm::codec_test;

  return codec_test();
}
