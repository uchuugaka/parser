			SAT のアルゴリズムについて

							2007年6月28日
							松永　裕介

1. 用語および問題の定義

 - 変数 v :
　 true(1) | false(0) のどちらかをとる変数．
   便宜上，値の割り当てられていないことを表す X も含めた 3値を取るよう
   に扱うこともある．

 - リテラル l = v^p (p = 1 or 0) :
   変数の肯定もしくは否定を表すもの．
   v^0 を肯定リテラル v^1 を否定リテラルとよぶ．
   肯定リテラルはもとの変数が true の時 true となる(充足される)．
   否定リテラルはもとの変数が false の時 true となる(充足される)．

 - 節 c = {l_1, l_2, ..., l_i, ...} :
   リテラルの集合．どれか一つのリテラルが true となったら節は充足され
   たと呼ぶ．

 - CNF :
   節の集合．全ての節が充足されたとき，CNF全体が充足されたと呼ぶ．

 - CNF-SAT 問題 :
   あたえられた CNF が充足可能かどうか判定する問題．
   充足可能の場合，充足解(充足させる変数の割り当て)の一つを出力するこ
   とが多い．
   さらに，充足解として，全ての変数に値が割り当てられているもの(完全割
   り当て解)を出力することが多い．一部の変数の値が未割り当てのものを部
   分割り当て解と呼ぶこともある．
   充足不可能の場合はただ単に充足不能と出力する場合と，Davis-Putnam ア
   ルゴリズムに基づいた resolution を出力する場合がある．

 - free variable:
   値が割り当てられていない変数

 - empty clause:
   ひとつも free variable を持たない，まだ充足していない節

 - unit clause:
   ただ一つの free variable を持つ，まだ充足していない節


2. 基本アルゴリズム

多くの SAT ソルバは Davis Putnam Logemann Loveland アルゴリズム(DPLL)
に基づいている．以下に矛盾に基づく学習を行う基本アルゴリズムを示す．

bool
DPLL
{
  forever {
    if ( decide_next_branch() ) {
      while ( 1 ) {
        // 値の割り当てに基づく他の変数への強制的な値の割り当てを調べる．
        deduce() // implication もしくは BCP とも呼ばれる．
        if ( conflict ) {
          // 矛盾の原因を解析して，学習する．
          blevel = analyze_conflicts();
          if ( blevel === 0 ) {
            // トップレベルの矛盾が起きた．
            return UNSAT;
          }
          backtrack(blevel);
        }
        else {
          break;
        }
      }
    }
    else {
      // 次の分岐がないということは全ての変数を割り当てたということ．
      return SAT;
    }
  }
}

decide_next_branch() では次に値を割り当てる変数とその値を選ぶ．これに
はさまざまなヒューリスティックが提案されている．もっとも単純な方法は未
割り当ての変数をあらかじめ決めておいた優先順位で選ぶ，というものである．

deduce() は値の割り当ての影響を他の変数へ伝搬させる処理を行う．実際の
SAT プログラムの実行時間の大部分を占める処理であり，実装方法にさまざま
な工夫が提案されているが，他の部分と異なり，この処理の結果は実装に関わ
らずユニークである．値の割り当てによっては deduce() の結果，矛盾が生じ
る場合がある．

analyze_conflicts() では矛盾を解析して，矛盾を解消するためのバックトラッ
クをどこまで行うべきかを計算する．通常は，直前の decision をキャンセル
すればよいが，後で述べるように矛盾の結果を反映した学習節が加えられてい
た場合には，数レベル前の decision まで戻って取り消さないと矛盾が解消し
ない場合がある．この矛盾の解析に基づくバックトラックと学習はオリジナル
の DPLL にはなかった処理で，GRASP, Chaff, MiniSat などで用いられている．
ただし，学習節をどのように構成するかはいくつかのヒューリスティックが提
案されており，結果として追加される節の形は唯一ではない．

backtrack() は指定されたレベルまでの値の割り当てを取り消す．値の割り当
てをどのような形で保持するかによって実装方法は変わるが，本質的に単純な
処理であり，結果もユニークである．


2.1 deduce

今，a + b + c' という節があったときに， a = 0, b = 0 という割り当てが
既になされていたとするとこの節を充足させるためには c = 0 でなければな
らない．このように，ただ一つの変数のみ値が未割り当ての未充足節は unit
clause と呼ばれ，残りのリテラルの値に従った値の割り当てが自動的になさ
れることになる．deduce のもっとも大きな処理は以前の割り当ての結果 unit
clause になった節を捜し出し，値の割り当てをキューに積むことである．
基本的には値の割り当て用のキューを用意しておいて，キューに要素がある限
り，割り当てを行う処理を繰り返せばよい．

ナイーブな方法としては上記の例でいうとリテラル a', b', c に関係する節
として a + b + c' を記録しておいて(符号が逆であることに注意)，a = 0 や
b = 0, c = 1 という割り当てが起こったら関連する節 a + b + c' が unit
clause かどうか判定すればよい．

しかし，巨大な CNF に対してこのようなナイーブな方法を用いると効率が悪
い．そこで，現代のSATソルバは 2-watch literal ヒューリスティック呼ばれ
るテクニックを用いている．これは全ての節に対して，監視すべきリテラルを
2つに限定するもので，場合によっては，unit clause になる可能性のない無
駄なチェックを大幅に削減することができるものである．基本的な原理は，2
つの watch literal が未割り当てな場合には他のリテラルの値を調べる必要
がないというものである．
今，v_1 + v_2 + v_3 + ... + v_100 という節があったとする．通常は 100個
の変数 v_1 〜 v_100 の値の割り当てに対してこの節が unit clause になっ
たかを調べなければならないが，v_1 と v_2 の2つのリテラルのみを watch
literal とした場合には v_3 〜 v_100 の98個の変数の割り当てに対しては全
く調べることなく unit clause でないと結論づけることが可能である．
もしも v_1 が 0になった場合には初めて v_3 〜 v_100 のリテラルを調べて
未割り当てのものがあるかどうかを調べる．見付かった場合にはそのリテラル
を v_1 の代わりに watch literal とする．そのような未割り当てのリテラル
が見付からなかった場合には v_1 のみが未割り当ての unit clause となるの
で，新たな値割り当てをキューに積めばよい．

2-watch literal 法の上手いところは watch literal の選びかたが任意の
未割り当てリテラルであればなんでもよいということから，バックトラックが
発生しても昔の watch literal に戻す必要がないというところにある．

unit clause による値割り当てが他の unit clause による割り当てと異なる
値を要求している場合には矛盾が生じる．値割り当てキューに積む前に値の割
り当てをおこなうものとすると(そうしておくと重複した同一の値割り当てを
キューに積むことがなくなる)，実際にはある節が empty clause になってい
ることに watch literal を調べることでわかることになる．そこで，その節
を deduce が失敗した理由として返すことにする．


2.2 analyze_conflicts

deduce の結果，C = a + b + c という節が empty clause になってしまった
とする．この場合，a = 0, b = 0, c = 0 となっているわけだから，a, b, c
の現在の値割り当てのうち最低1つは取り消して，反対の値にしなければ矛盾
は解消しない．つまり，もっとも単純な矛盾の解決条件は a + b + c となる．
これはもとの C と全く同じで新たな情報をまったく与えてはいないが，もし
も a = 0 が a' + d + e という節(および d = 0, e = 0 という割り当て)に
よって割り当てられていたとすると，(a = 1) -> d + e より，上記の C 中の
a を d + e に置き換えて C1 = b + c + d + e という節を作ることができる．
また，b = 0 が b' + f + g という節(および f = 0, g = 0 という割り当て)
によるものだとすると，(b = 1) -> f + g より上記の C中の b を f + g に
置き換えて，C2 = a + c + f + gという節を作ることもできるし，さらには
C1 中の b を置き換えて C3 = c + d + e + f + gという節を作ることもでき
る．これらの節をもとの CNF に加えることで充足性は変化しない．つまり，
もとの問題が充足可能であれば，全く同一の充足可能解によって新しい問題も
充足されるし，もとの問題が充足不可能であれば新しい問題もまた充足不可能
となる．(Davis Putnam の resolution を用いて簡単に証明することができる)．
このような矛盾が生じる条件の解析を行うために含意グラフと呼ばれるグラフ
を考えることにする．

全ての値割り当ては，その理由によって次の2つの種類に分類される．

- 決定によるもの: decide_next_branch() で直接，選ばれたもの
- 含意によるもの: 他の値割り当ての結果，deduce() 中で割り当てられたも
		  の

決定による割り当てには理由は存在しない．一方，含意による割り当てにはそ
の理由となる節および，他の値割り当てが存在する．そこで，値割り当てを節
点として，値割り当て間の直接の依存関係を枝で表したグラフを考え，それを
含意グラフと呼ぶことにする．
もちろん，決定による割り当てノードは入り枝をもたない．
また，含意グラフは内部にサイクルを持たない DAG となることは自明である．

今，矛盾の起こった割り当てノードを T とし，仮想的なソースノード Sを含
意グラフに追加し，S から決定による割り当てノードへ仮想的な枝を張るもの
とする．このグラフ上の S を始点として T を終点とする全てのパスを2つに
分割するようなノード集合(グラフ理論でいうところのセパレータ)を考える．
そのようなノード集合を R = {l_1, l_2, ...} とすると，すべての l_i が成
り立ってしまうとノード T において矛盾が生じてしまうことを意味する．
逆にいうと，含意グラフ上の任意のセパレータ中の割り当てのうち，最低1つ
はキャンセルする必要がある，ということになる．

矛盾の解析とは上記のように含意グラフ上のセパレータをなんらかの方法で求
めて，そのセパレータに含まれるリテラルの否定を集めたものを学習節として
問題に追加するものである．明らかなようにそのようなセパレータの求めかた
は唯一ではないので，いくつかのヒューリスティックが提案されている．

GRASP で提案されている単純な方法は，以下の条件を満たすノードをセパレー
タとするものである．
 - その割り当てのレベルが現在の decision level よりも小さい．
または，
 - 現在の decision level の決定ノード

GRASP ではもう少し複雑なセパレータも提案している．これは UIP (unique
implication point)と呼ばれる概念を用いるものである．まず，含意グラフ上
で現在の decision level の割り当てのみからなる部分グラフを考える．
すると，グラフ中の全てのパスは現在の decision level における決定ノード
を始点として矛盾の起こった割り当てノードを終点とすることになる．
もしも，これらの全てのパスが必ず通過するノードが始点と終点以外に存在す
る場合(グラフ理論における支配点)，そのようなノードを UIP と呼ぶ．
支配点の性質上，いかなるパスにおいても各支配点が表れる順序は唯一である
ので，ここでは支配点を終点 T に近い順に並べるものとする．
UIP を用いるアイデアは， UIP が含意グラフ上の「ボトルネック」になって
いるという観察に基づくものである．つまり，UIP 以外のノードを含むセパレー
タが存在する場合には，そのセパレータよりも要素数の少ないUIPを含むセパ
レータが必ず存在する．

Chaff ではそのようなUIPのうち，もっとも終点に近いものを first UIP と名
付けて，first UIP および，現在の decision level よりも小さいレベルのノー
ドからなるセパレータを用いるヒューリスティックを提案している．

いかなる場合でも，生成された学習節は現在の decision level では empty
clause となっているはずである．そこで，バックトラックではこの学習節が
unit clause になるまで値の割り当てをキャンセルする必要がある．そこで，
analyze_conflicts の最後の処理は学習節に含まれる変数のうち，先頭(かな
らず現在の割り当てレベルになっている)を除いた残りのなかの割り当てレベ
ルの最大値を計算し，それをバックトラックすべきレベルとすることである．
正確には，バックトラックすべきレベル l は

現在の割り当てレベル > l >= 残りの変数の割り当てレベルの最大値

となる．つなり，最低で1つは戻らなければならないが，今，生成された学習
節のなかに含まれる残りの変数の割り当てレベルまでは戻っても(残りの変数
割り当てはキャンセルされない)，唯一に含意される割り当ては変わらないの
で，できるかぎり多く戻る戦略がとられている．



3. 実装

3.1 論理値

X を表すために tBool3 という型を定義する．
とりうる値は
 - kB3False = false,
 - kB3True = true,
 - kB3X
の3値である．

関数は
 - tBool3 operator~(tBool3 val)      : 否定演算子．ただし kB3X は変化しない
 - tBool3 b2B3(bool b)               : 2値から3値への変換
 - ostream<<(ostream& s, tBool3 val) : 値を出力する
が定義されている．


3.2 変数

ymtools/ym_lexp の共通型である tVarId をそのまま用いる．

ただし，後述する用に変数に関連する情報としては，以下の情報を保持してお
く．
 - 値(未定，true, false)
 - 割り当てが行われたレベル
 - 割り当ての理由
 - アクティビティ


3.3 リテラル

ymtools/ym_lexp の共通型である Literal をそのまま用いる．


3.4 節　SatClause

SatSolver のユーザーは直接触ることはないので libym_sat 内で定義されて
いる．抽象的なデータ構造としてはリテラルの集合だが，処理速度のために領
域確保の方法がすこし凝った実装となっている．

節には，問題として与えられるもの(制約節)と矛盾解析の結果，生成されるも
の(学習節)がある．制約節は一度加えられたら不変だが，学習節は場合によっ
ては削除される場合もある．そのために，activity という double の値を保
持している．すべての学習節の activity はだんだんと減衰して行くが，矛盾
の検出に関連した学習節の activity 値は一定の値だけ増加される．

あとで述べるように節は，watch literal や含意の原因を表す目的でも使用さ
れる．


3.5 watch literal

2.1 deduce で述べたように，各々の節について，2つの watch literal を設
定する必要があるが，もっとも簡単な方法は常に節の1番めと2番めのリテラル
を watch literal にすることである．watch literal が割り当ての結果
false になった場合には他の false でないリテラル(true でも未定でもよい)
を探して，そのリテラルと位置を入れ替えればよい．もしも，そのようなリテ
ラルが見つからない時には，watch literal が一つしか存在しないことになる
ので，自動的に含意が行われる．

ある変数に割り当てが行われたとき，その値と反対の値に対応するリテラルを
watch している節は一つ watch literal が減ることになるので，処理が必要
となる．そのため，変数の各々の値に対して，その値割り当てによって false
となるリテラルを watch literal として持つ節のリストを持っておき，
deduce の時にそのリストにしたがって含意を行う．

ただし，2つのリテラルからなる節の場合，一方のリテラルが false になると
いうことはもう一方のリテラルが充足されるような値割り当てが即，実行され
ることを意味する．そのため2つのリテラルからなる節の場合，上記のリスト
に節ではなく，反対のリテラルその物を格納しておく．これを実装する為には，
節(へのポインタ)とリテラルの両方を表せるクラスが必要となる．
ここでは次で述べる割り当て理由を表すクラスを流用している．


3.6 値割り当て理由 SatReason

含意によって値が割り当てられた場合，その割り当ての原因となっている他の
割り当てが存在する．例えば， (a' + b + c) という節において
 a = 1, b = 0 という割り当てがなされたら c = 1 にしないと節が充足され
ない．この場合，c = 1 という割り当ての原因は a = 1 and b = 0 である．
このように割り当ての原因は節を用いて表すことができる．
ただし，(a' + b) のように2つのリテラルからなる節に対して a = 1 から b
= 1が含意された場合，これは a = 1 つまり a というリテラルで割り当ての
理由を表すこともできる．そのため，節へのポインタとリテラルの両方を表現
可能なクラスを用意して，各変数に値の割り当てが行われたときには，その理
由を格納するようにする．バックトラックが起こって値の割り当てが取り消さ
れたときにはこの理由もクリアされる必要があるが，値の割り当てられていな
い変数に対しては値の割り当てを見ることはないので特に変更する必要はない．


3.7 値割り当て履歴 AssignList

バックトラック時にはそれまでの値割り当てを取り消す必要がある．そのため，
各割り当てレベルごとに割り当ての記録を保持する必要がある．
実際には，同じレベルの割り当ては時系列的には連続しているので，一つの配
列に値割り当てを保持しておき，どこからどこまでがそのレベルの割り当てか
が分かるようにしておけばよい．

また，含意操作の際には，この配列を次に処理すべき変数を入れておくキュー
として用いることもできる．通常は処理を行った後にキューから取り出すが，
前述の割り当ての履歴を表すためにそのまま残しておけばよい．


3.8 変数ヒープ

Chaff や MiniSat で用いられているヒューリスティックにアクティビティに
基づく変数選択がある．これは，選択的な決定を行うときの変数をアクティビ
ティと呼ぶ指標の最大のものを選ぶというものである．
アクティビティの具体的な設定方法はいくつか考えられるが，大まかには以下
のようなルールになっている．

 - 初期状態では全ての変数のアクティビティは 0
 - 矛盾の解析時に関連する変数のアクティビティを一定の値だけ増加させる．
 - 矛盾が起こるごとに(選択的な決定が起こるごとに)，すべての変数のアク
   ティビティは定率で減少する．

Chaff では変数ではなく，リテラルにアクティビティが付いているが，
MiniSat では上記のように変数単位でアクティビティを扱っている．

明らかに，値を持つ要素の集合のなかから最大の値を持つ要素を取り出す，と
いう操作に適している抽象データ型はヒープ木である．そこで，この目的のた
めに変数はヒープ木に格納しておく．
少し考慮が必要なことは，変数のアクティビティは一定ではなく，たとえ，変
数がヒープ木の中に入っていたとしても変動しうるというとである．
ただし，ここで考慮する必要のあるのは，

1. ある一つの変数のアクティビティのみが増加する．
2. すべての変数のアクティビティが定率で減少する．

という2つの場合だけである．1. の場合，その変数の位置が現在の位置よりも
上にあがる可能性があるので，親と値を比較して逆転していたら親と交換する
という処理を適切な位置になるまで繰り返せばよい．

2. の場合は実は相対的な大小関係は不変なのでなにもする必要はない．

さらに，毎回，すべての変数のアクティビティを減少させるのは手間なので，
逆に毎回，変数に加える増分を減少分の逆数分だけ大きくする，というトリッ
クを用いる．もちろん，これを繰り返すと値がオーバーフローしてしまうので，
適当な大きさになったときに，変数全体に対していままでサボってきた減少率
をまとめてかける操作を行う．
